---
title: Структура научной презентации
subtitle: Простейший вариант
author:
  - name: Малюга Валерия Васильевна



    affiliation:
      - name: Российский университет дружбы народов
        country: Российская Федерация
        postal-code: 117198
        city: Москва
        address: ул. Миклухо-Маклая, д. 6
date: "2025-05-16"

## i18n babel
babel-lang: russian
babel-otherlangs: english

## Formatting pdf
toc: false
toc-title: Содержание
slide_level: 2
aspectratio: 169
section-titles: true
theme: metropolis
header-includes:
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
---


output:
  revealjs:
    theme: beige
    transition: slide
    margin: 0.2
    smaller: false
    logo: _resources/image/logo_rudn.png
---

# Информация

## Докладчик

:::::::::::::: {.columns align=center}
::: {.column width="70%"}

  * Малюга Валерия Васильевна
  * студент
  * Российский университет дружбы народов им. П. Лумумбы
  * [1132236050@rudn.ru](mailto:1132236050@rudn.ru)
  * <https://yamadharma.github.io/ru/>

:::
::: {.column width="30%"}


:::
::::::::::::::

# Вводная часть

## Актуальность: Переполнение буфера

- Один из самых распространённых механизмов атак
  - Впервые применён в черве Морриса (1988)
- Несмотря на наличие методов защиты, уязвимость остаётся актуальной:
  - Устаревшее ПО
  - Небезопасные практики программирования
- Актуально для систем на C/C++ и других низкоуровневых языках

## Что такое переполнение буфера

Ошибка программирования, при которой данные записываются за пределы выделенного буфера.

**Последствия:**

- Перезапись соседних областей памяти (другие переменные, параметры, управляющие данные)
- Повреждение данных
- Нарушение управления потоком исполнения
- Нарушение доступа к памяти
- Потенциальное выполнение вредоносного кода

**Места возникновения:**
- Стек
- Куча
- Сегмент данных

## Пример уязвимого кода

```c
int main(int argc, char *argv[]) {
  int valid = 0;
  char str1[8]; char str2[8];
  strcpy(str1, "START");
  gets(str2);
  if (strncmp(str1, str2, 8) == 0) valid = 1;
  printf("str1(%s), str2(%s), valid(%d)\n", str1, str2, valid);
}
```

## Атаки с переполнением буфера

Чтобы использовать уязвимость переполнения буфера, злоумышленнику необходимо:
- обнаружить уязвимость переполнения буфера в программе, которую можно вызвать с помощью внешних данных, находящихся под контролем злоумышленника;
- понять, как буфер хранится в памяти, и определить возможность его повреждения.

Идентифицировать уязвимые программы можно с помощью:
- анализа исходного кода программы;
- отслеживания выполнения программ при обработке чрезмерно большого ввода;
- использования инструментов, таких как fuzzing (фаззинг), для автоматического выявления потенциально уязвимых программ.


---

## Введение в эксплуатацию уязвимостей (Exploit Development)

Эксплуатация переполнения буфера — это процесс создания специальных данных (payload), которые используют уязвимость для изменения поведения программы. Среди основных техник:

- **Shellcode** — небольшой код на машинном языке, который выполняет действия, желаемые злоумышленником (например, открывает командную оболочку). Shellcode внедряется в память и запускается через переполнение.

- **ROP-цепочки (Return-Oriented Programming)** — техника, которая используется, когда прямая вставка и выполнение shellcode запрещена (например, включена DEP). ROP использует фрагменты существующего кода программы (гаджеты), комбинируя их для выполнения вредоносных действий без внедрения нового кода.

Эти методы требуют глубокого понимания архитектуры процессора, структуры памяти и особенностей исполняемого кода. Современные защитные механизмы значительно усложняют разработку успешных эксплойтов, однако они по-прежнему остаются актуальной проблемой безопасности.

---

## Способы предотвращения

Для предотвращения **переполнения буфера (buffer overflow)** рекомендуется использовать комплексный подход, включающий как меры на уровне программного кода, так и механизмы защиты операционной системы:

### 1. Контроль границ буфера

- Следует проверять размер входных данных перед записью в буфер.  
- Желательно избегать работы с памятью без явной валидации длины строк и массивов.  
- Рекомендуется использовать условия и циклы, исключающие выход за допустимые границы.

### 2. Использование безопасных функций

- Предпочтение следует отдавать безопасным альтернативам:  
  – `strncpy` вместо `strcpy`,  
  – `snprintf` вместо `sprintf`,  
  – `memcpy_s` вместо `memcpy`.  
- Следует применять функции, принимающие аргумент длины и предотвращающие выход за пределы буфера.

### 3. Обновление программного обеспечения

- Необходимо регулярно устанавливать обновления операционной системы, библиотек и приложений.  
- Патчи безопасности следует применять сразу после их выпуска.  
- В случае возможности рекомендуется использовать автоматическое обновление.

### 4. Защита на уровне операционной системы

- Применяется **ASLR (Address Space Layout Randomization)** — рандомизация расположения памяти для затруднения атак.  
- Используется **DEP/NX-bit (Data Execution Prevention)** — предотвращение выполнения кода в сегментах данных.  
- Реализуются **stack canaries** — специальные значения в стеке для выявления попыток переполнения.  
- При компиляции включаются защитные флаги, такие как `-fstack-protector`.

### 5. Анализ и тестирование

- Рекомендуется использовать статический и динамический анализ для выявления уязвимостей.  
- Применяется **fuzzing** — автоматическое тестирование с помощью случайного ввода.  
- Периодически проводится аудит безопасности и ревизия кода.

### 6. Ограничение прав и изоляция

- Программы запускаются с минимально необходимыми правами.  
- Для повышения безопасности используются механизмы контейнеризации и песочницы (sandbox).


